<form version="1.1">
  <label>Broken Hosts Monitored Log Sources</label>
  <fieldset submitButton="true">
    <input type="time" token="time_tok" searchWhenChanged="true">
      <label>Time Picker</label>
      <default>
        <earliest>-30d@d</earliest>
        <latest>now</latest>
      </default>
    </input>
    <input type="dropdown" token="monitored_by" searchWhenChanged="true">
      <label>Log Sources to Show</label>
      <choice value="(`bh_hl_alerting`)">Hurricane Labs Monitored</choice>
      <choice value="(`bh_client_alerting`)">Client Monitored</choice>
      <choice value="NOT (`bh_hl_alerting`) AND NOT (`bh_client_alerting`)">Unmonitored</choice>
      <choice value="">All</choice>
      <default>(`bh_hl_alerting`)</default>
      <initialValue>(`bh_hl_alerting`)</initialValue>
    </input>
  </fieldset>
  <row>
    <panel>
      <title>Current Alerts</title>
      <table>
        <title>Shows all currently alerting data sources under currently selected monitoring group.</title>
        <search>
          <query>index=summary source="bh_stats_gen" AND $monitored_by$ | `bh_alert_additions` | rex field=eventtype "bh_aggregate-(?&lt;aggregate_fields&gt;.*)" | eval aggregate_fields=if(isnull(aggregate_fields),orig_index.",".orig_sourcetype.",".orig_host,aggregate_fields)
| stats max(latest_time) as latest_time values(eventtype) as eventtype sum(count) as count by aggregate_fields | rex field=aggregate_fields "(?&lt;index&gt;[^,]+),(?&lt;sourcetype&gt;[^,]+),(?&lt;host&gt;.*)"
| eval host=lower(host),index=lower(index),sourcetype=lower(sourcetype)
| lookup expectedTime index,host,sourcetype OUTPUT _key AS key, lateSecs, comments, contact, suppressUntil 
| fillnull value="-" comments, contact
| fillnull value="0" lateSecs, suppressUntil
| eval output=mvzip(key, mvzip(suppressUntil, mvzip(comments, mvzip(contact, lateSecs, "|||"), "|||"), "|||"), "|||")
| mvexpand output
| eval key=mvindex(split(output, "|||"), 0), suppressUntil=mvindex(split(output, "|||"), 1), comments=mvindex(split(output, "|||"), 2), contact=mvindex(split(output, "|||"), 3), lateSecs=mvindex(split(output, "|||"), 4)
| sort 0 + key
| fields - key, output
| stats first(*) AS * by index, host, sourcetype
| convert auto(suppressUntil) 
| fillnull value=`default_expected_time` lateSecs
| eval lateSecs=if(suppressUntil &gt; now(),0,lateSecs) 
| eval lastAllowed=round(coalesce(relative_time(now(), lateSecs),now()-lateSecs),0) | lookup bh_status.csv index sourcetype host OUTPUT status as old_status
| eval status=if(lateSecs != "0" AND ((latest_time &lt; lastAllowed) OR (latest_time &gt; now() + 3000)) AND (now() - latest_time &lt; `ignore_after`) AND searchmatch("NOT eventtype=bh_suppress*") AND count &gt; `min_count`, "CRITICAL", "OK")
| where (status=="CRITICAL" OR isnotnull(old_status)) AND (status!="OK" OR old_status!="OK")
| eval howLateSecs=now() - latest_time 
| sort latest_time
| convert ctime(lastAllowed) AS lastAllowed, ctime(latest_time) AS latest_time
| table index, sourcetype, host, aggregate_fields, count, status, latest_time, lastAllowed, lateSecs
| rename index AS Index, sourcetype AS Sourcetype, host AS Host, count AS "Log Source Event Count", status AS Status, latest_time AS "Last Log Seen", lastAllowed AS "Timestamp of Threshold for Critical Status", lateSecs AS "Threshold (in Seconds)", suppressUntil_commented AS "Suppression Information with Comments", aggregate_fields AS "Data Source with Aggregates Applied"</query>
          <earliest>-30d@d</earliest>
          <latest>+7d@d</latest>
        </search>
        <option name="drilldown">none</option>
        <option name="refresh.display">progressbar</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <title>Suppressed Log Sources Receiving Data</title>
      <table>
        <title>This panel shows log sources that are suppressed in expectedTime that have received logs within the time range selected above.</title>
        <search>
          <query>index=summary source="bh_stats_gen" $monitored_by$ | `bh_alert_additions`  | rex field=eventtype "bh_aggregate-(?&lt;aggregate_fields&gt;.*)" | eval aggregate_fields=if(isnull(aggregate_fields),orig_index.",".orig_sourcetype.",".orig_host,aggregate_fields)
| stats max(latest_time) as latest_time values(eventtype) as eventtype sum(count) as count by aggregate_fields | rex field=aggregate_fields "(?&lt;index&gt;[^,]+),(?&lt;sourcetype&gt;[^,]+),(?&lt;host&gt;.*)"
| lookup expectedTime index,host,sourcetype OUTPUT _key AS key, lateSecs, comments, contact, suppressUntil
| fillnull comments contact value=""
| fillnull suppressUntil value=0
| fillnull value=`default_expected_time` lateSecs
| eval output=mvzip(key, mvzip(suppressUntil, mvzip(comments, mvzip(contact, lateSecs, "|||"), "|||"), "|||"), "|||")
| mvexpand output
| eval key=mvindex(split(output, "|||"), 0), suppressUntil=mvindex(split(output, "|||"), 1), comments=mvindex(split(output, "|||"), 2), contact=mvindex(split(output, "|||"), 3), lateSecs=mvindex(split(output, "|||"), 4)
| sort 0 + key
| fields - key, output
| stats first(*) AS * by index, host, sourcetype
| convert auto(suppressUntil)
| fillnull value=`default_expected_time` lateSecs
| eval lateSecs=if(suppressUntil &gt; now(),0,lateSecs) 
| eval lastAllowed=round(coalesce(relative_time(now(), lateSecs),now()-lateSecs),0) 
| lookup bh_status.csv index sourcetype host OUTPUT status as old_status
| eval status=if(lateSecs != "0" AND ((latest_time &lt; lastAllowed) OR (latest_time &gt; now() + 3000)) AND (now() - latest_time &lt; `ignore_after`) AND searchmatch("NOT eventtype=bh_suppress*") AND count &gt; `min_count`, "CRITICAL", "OK")
| convert ctime(suppressUntil) AS suppressTimestamp
| eval suppressUntil_commented=case((suppressUntil=0 AND lateSecs=0),"Permanent Suppression - " + comments, (suppressUntil!=0 OR lateSecs=0), suppressTimestamp + " - " + comments, 1==1, "Not Suppressed")
| convert ctime(lastAllowed) AS lastAllowed, ctime(latest_time) AS latest_time
| table index, sourcetype, host, count, status, latest_time, lastAllowed, lateSecs, suppressUntil_commented
| search suppressUntil_commented!="Not Suppressed"
| rename index AS Index, sourcetype AS Sourcetype, host AS Host, count AS "Log Source Event Count", status AS Status, latest_time AS "Last Log Seen", lastAllowed AS "Timestamp of Threshold for Critical Status", lateSecs AS "Threshold (in Seconds)", suppressUntil_commented AS "Suppression Information with Comments"</query>
          <earliest>$time_tok.earliest$</earliest>
          <latest>$time_tok.latest$</latest>
        </search>
        <option name="drilldown">none</option>
        <option name="refresh.display">progressbar</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <title>All Suppressions</title>
      <table>
        <title>This panel lists all suppressions found in expectedTime, regardless of whether they have logged within the selected time range or not. A value of '*' (wildcard) indicates that this suppression will apply to whatever index/sourcetype/host the non-wildcard fields come in to.</title>
        <search>
          <query>| inputlookup expectedTime
| eval suppressUntil_epoch=if(suppressUntil!="0", round(strptime(suppressUntil, "%m/%d/%Y %H:%M:%S"),0), 0)
| where lateSecs=0 OR suppressUntil_epoch&gt;now() 
| eval suppressUntil=if(suppressUntil=0,"Permanent Suppression",suppressUntil)
| eval comments=suppressUntil + " - " + comments
| fields index, sourcetype, host, suppressUntil, comments 
| rename index AS "Index" sourcetype AS "Sourcetype" host AS "Host", comments as "Suppression Time with Comments", suppressUntil AS "Suppress Until"</query>
          <earliest>$time_tok.earliest$</earliest>
          <latest>$time_tok.latest$</latest>
        </search>
        <option name="drilldown">none</option>
        <option name="refresh.display">progressbar</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <title>All Aggregates</title>
      <table>
        <title>This panel lists all aggregates that have been created within Broken Hosts.</title>
        <search>
          <query>| rest splunk_server=local servicesNS/-/broken_hosts/saved/eventtypes | search title=bh_* | fields title eai:acl.app eai:acl.owner search | rename title AS Eventtype, eai:acl.app AS App, eai:acl.owner AS Owner, search AS Search</query>
          <earliest>-24h@h</earliest>
          <latest>now</latest>
        </search>
        <option name="drilldown">none</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <title>Non-Suppressed Log Sources Receiving Data</title>
      <table>
        <title>This panel will show all non-suppressed log sources that have received data within the time range selected. Additional log sources may appear a longer time range is selected above.</title>
        <search>
          <query>index=summary source="bh_stats_gen" $monitored_by$ | `bh_alert_additions`  | rex field=eventtype "bh_aggregate-(?&lt;aggregate_fields&gt;.*)" | eval aggregate_fields=if(isnull(aggregate_fields),orig_index.",".orig_sourcetype.",".orig_host,aggregate_fields)
| stats max(latest_time) as latest_time values(eventtype) as eventtype sum(count) as count by aggregate_fields | rex field=aggregate_fields "(?&lt;index&gt;[^,]+),(?&lt;sourcetype&gt;[^,]+),(?&lt;host&gt;.*)"
| lookup expectedTime index,host,sourcetype OUTPUT _key AS key, lateSecs, comments, contact, suppressUntil
| fillnull comments contact value=""
| fillnull suppressUntil value=0
| fillnull value=`default_expected_time` lateSecs
| eval output=mvzip(key, mvzip(suppressUntil, mvzip(comments, mvzip(contact, lateSecs, "|||"), "|||"), "|||"), "|||")
| mvexpand output
| eval key=mvindex(split(output, "|||"), 0), suppressUntil=mvindex(split(output, "|||"), 1), comments=mvindex(split(output, "|||"), 2), contact=mvindex(split(output, "|||"), 3), lateSecs=mvindex(split(output, "|||"), 4)
| sort 0 + key
| fields - key, output
| stats first(*) AS * by index, host, sourcetype
| convert auto(suppressUntil)
| fillnull value=`default_expected_time` lateSecs
| eval lateSecs=if(suppressUntil &gt; now(),0,lateSecs) 
| eval lastAllowed=round(coalesce(relative_time(now(), lateSecs),now()-lateSecs),0) 
| lookup bh_status.csv index sourcetype host OUTPUT status as old_status
| eval status=if(lateSecs != "0" AND ((latest_time &lt; lastAllowed) OR (latest_time &gt; now() + 3000)) AND (now() - latest_time &lt; `ignore_after`) AND searchmatch("NOT eventtype=bh_suppress*") AND count &gt; `min_count`, "CRITICAL", "OK")
| convert ctime(suppressUntil) AS suppressTimestamp
| eval suppressUntil_commented=case((suppressUntil=0 AND lateSecs=0),"Permanent Suppression - " + comments, (suppressUntil!=0 OR lateSecs=0), suppressTimestamp + " - " + comments, 1==1, "Not Suppressed")
| convert ctime(lastAllowed) AS lastAllowed, ctime(latest_time) AS latest_time
| search suppressUntil_commented="Not Suppressed"
| table index, sourcetype, host, count, status, latest_time, lastAllowed, lateSecs, comments
| rename index AS Index, sourcetype AS Sourcetype, host AS Host, count AS "Log Source Event Count", status AS Status, latest_time AS "Last Log Seen", lastAllowed AS "Timestamp of Threshold for Critical Status", lateSecs AS "Threshold (in Seconds)", suppressUntil_commented AS "Suppression Information with Comments", comments AS Comments</query>
          <earliest>$time_tok.earliest$</earliest>
          <latest>$time_tok.latest$</latest>
        </search>
        <option name="drilldown">none</option>
        <option name="refresh.display">progressbar</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <title>Broken Hosts Alerts</title>
      <table>
        <title>Shows alerts that have been sent to HL, if they have been seen, their status, and the associated ticket number. Requires Hurricane Customer Metrics app to be installed and configured.</title>
        <search>
          <query>| inputlookup hurricane_alerts where tags="broken_hosts_alert"
| eval _time=strptime(createdAt, "%Y-%m-%dT%H:%M:%S.%3N%Z"), ticket=mvfilter(match(tags,"zd_"))
| eval updated_at_epoch=strptime(updatedAt, "%Y-%m-%dT%H:%M:%S.%3N%Z"), ticket=mvfilter(match(tags,"zd_"))
| stats sum(count) AS alerts, earliest(_time) as first_alert_created, latest(_time) as last_alert_created, latest(updated_at_epoch) AS last_alert_updated, latest(seen) AS seen, latest(status) as status, values(ticket) AS ticket by message
| eval days=round(((last_alert_updated-last_alert_created)/86400), 2)
| where status="open"
| convert ctime(earliest_time) as earliest_time, ctime(latest_time) as latest_time
| sort - days
| rex field=ticket "(?&lt;zd_ticket&gt;\d+)"
| fields - ticket
| convert ctime(first_alert_created) AS "First Alert Created", ctime(last_alert_created) AS "Last Alert Created", ctime(last_alert_updated) AS "Last Alert Update"
| rename message AS Alert, alerts AS "Number of Alerts", earliest_time AS "Earliest Time", latest_time AS "Latest Time", seen AS "Seen by Analyst?", status AS Status, zd_ticket AS "Ticket Number", days as "Days Open"</query>
          <earliest>0</earliest>
          <latest></latest>
        </search>
        <option name="drilldown">none</option>
        <option name="refresh.display">progressbar</option>
      </table>
    </panel>
  </row>
</form>